module bio.tree (*)

-- This type alias importing is getting a bit ludicrous
import conventions (Int, Bool, Str, Real, Tuple2, Tuple3, List, Map, Unit)
import base (snd, map, join, ne)

source Cpp from "tree.hpp"
  ( "mlc_pack_tree" as packTree
  , "mlc_unpack_tree" as unpackTree
  , "mlc_node" as node
  , "mlc_subtrees" as subtrees
  , "mlc_childLeafs" as childLeafs
  , "mlc_edgeMap" as edgeMap
  , "mlc_push" as push
  , "mlc_push_val" as pushVal
  , "mlc_pull" as pull
  , "mlc_pull_val" as pullVal
  , "mlc_treeBy" as treeBy
  , "mlc_foldTree" as foldTree
  , "mlc_alterTree" as alterTree
  , "mlc_mapNode" as mapNode
  , "mlc_mapLeaf" as mapLeaf
  , "mlc_mapEdge" as mapEdge
  )

source R from "tree.R" ("mlc_pack_tree_phylo" as packTree, "mlc_unpack_tree_phylo" as unpackTree)
source Python3 from "tree.py" ("mlc_pack_tree_dendropy" as packTree, "mlc_unpack_tree_dendropy" as unpackTree)

type R (Tree n e l) = "phylo" n e l 
type Py (Tree n e l) = "dendropy" n e l 
type Cpp (Tree n e l) = "Tree<$1,$2,$3>" n e l 

packTree :: pack => ([n], [(Int, Int, e)], [l]) -> Tree n e l 
unpackTree :: unpack => Tree n e l -> ([n], [(Int, Int, e)], [l])

packTree Cpp   :: pack   => ([n], [("int", "int", e)], [l]) -> "Tree<$1,$2,$3>" n e l  
unpackTree Cpp :: unpack => "Tree<$1,$2,$3>" n e l -> ([n], [("int", "int", e)], [l])

-- A few tricky points, R is 1-based, but morloc is 0-based. This means that
-- when packing and unpacking indices need to be tweaked. In fact, I should add
-- a dedicated Index type.
packTree R   :: pack   => (["character"], [("integer", "integer", "numeric")], ["character"]) -> "phylo" "character" "numeric" "character"
unpackTree R :: unpack => "phylo" "character" "numeric" "character" -> (["character"], [("integer", "integer", "numeric")], ["character"])

packTree Py   :: pack   => (["str"], [("int", "int", "float")], ["str"]) -> "dendropy" "str" "float" "str"
unpackTree Py :: unpack => "dendropy" "str" "float" "str" -> (["str"], [("int", "int", "float")], ["str"])

source R from "ape.R" ("randomTree")

randomTree :: Int -> Tree Str Real Str
randomTree R :: "integer" -> "phylo" "character" "numeric" "character"

treeBy :: ([b] -> Tree n e Int) -> [(l, b)] -> Tree n e l

------- Atom Operations --------------------------------------------------------

node :: Tree n e l -> n
subtrees :: Tree n e l -> [(e, Tree n e l)]
childLeafs :: Tree n e l -> [(e, l)]

edgeMap :: Tree n e l -> Map Int (Int, e)

root :: Tree n e l -> Int
root = head . filter ne . enumerate . sort . fst . values . edgeMap


------- Pull Operations -------------------------------------------------------

-- general function for pulling values from tip to root
pullVal :: (l -> (a, n'))
        -> (n -> e -> a -> n' -> e')
        -> (n -> [(e', n', a)] -> (a, n'))
        -> Tree n e l
        -> Tree n' e' l

pull :: (l -> n')
     -> (n -> e -> n' -> e')
     -> (n -> [(e', n')] -> n')
     -> Tree n e l
     -> Tree n' e' l

-- pull values from leaf to root
pullNode :: (l -> n') -> ([n'] -> n') -> Tree n e l -> Tree n' e l
pullNode f g = pull
    (\l -> f l) -- generate n' using f
    (\n e n' -> e) -- do not change the edge
    (\n es -> g (map snd es)) -- create new node from child nodes, ignore the current node value

------- Push Operations -------------------------------------------------------

-- push a value down a tree, changing the node, edge and leaf types, but preserving topology
pushVal :: (a -> n -> n')
        -> (a -> n' -> e -> n -> (e', n'))
        -> (a -> n' -> e -> l -> (e', l'))
        -> (Tree n e l -> a -> a)
        -> a
        -> Tree n e l
        -> Tree n' e' l'

push :: (n -> n')
     -> (n' -> e -> n -> (e', n'))
     -> (n' -> e -> l -> (e', l'))
     -> Tree n e l
     -> Tree n' e' l'

mapNode :: (n -> n') -> Tree n e l -> Tree n' e l
mapNode f
    = push
      (\ n -> f n) -- at the root, ignore the accululator, after the node with the given function `f`
      (\ n' e n -> (e, f n)) -- at each internal node, ignore the accumulator and context and alter the node with `f`
      (\ n' e l -> (e, l)) -- do not change the leaf values

mapEdge :: (e -> e') -> Tree n e l -> Tree n e' l
mapEdge f = push (\ n -> n) (\ n' e n -> (f e, n)) (\ n' e l -> (f e, l))

mapLeaf :: (l -> l') -> Tree n e l -> Tree n e l'
mapLeaf f = push (\ n -> n) (\ n' e n -> (e, n)) (\ n' e l -> (e, f l))

mapChildWithParent :: (n -> n') -> (n' -> n -> n') -> Tree n e l -> Tree n' e l
mapChildWithParent f g
    = push
      (\ n -> f n)
      (\ n' e n -> (e, g n' n))
      (\ n' e l -> (e, l))


------- Fold Operations -------------------------------------------------------

foldTree :: (a -> a -> a) -> (Tree n e l -> a) -> a -> Tree n e l -> a

nodes :: Tree n e l -> [n]
nodes = foldTree join (\t -> ifelse isNode [node t] []) []

edges :: Tree n e l -> [e]
edges = foldTree join (map fst . kids) []

leafs :: Tree n e l -> [l] -- yes, that is how I pluralize leaf
leafs = map snd . foldTree join childLeafs []


------- Topo Operations -------------------------------------------------------

-- change the topology of a tree, but not its type
alterTree :: (n -> [(e, Tree n e l)] -> [(e, Tree n e l)]) -> Tree n e l -> Tree n e l

filterNode :: (n -> Bool) -> Tree n e l -> Tree n e l
filterNode f = alterTree (\n es -> filter (\t -> ifelse (isNode t) (f (node t)) True) es)

filterEdge :: (e -> Bool) -> Tree n e l -> Tree n e l
filterEdge f = alterTree (\ n es -> filter (f . fst) es)

filterLeaf :: (v -> Bool) -> Tree n e l -> Tree n e l
filterLeaf f = alterTree (\n es -> filter (\t -> ifelse (isNode t) True (f (leaf t))) es)
